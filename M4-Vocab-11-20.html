<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Unicorn Rainbow Spelling Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            background: radial-gradient(circle, #fdf2f8 0%, #fae8ff 100%);
            /* Allow vertical scrolling */
            overflow-y: auto;
            overflow-x: hidden;
            touch-action: manipulation;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        
        #game-container {
            position: relative;
            box-shadow: 0 20px 50px rgba(244, 114, 182, 0.3);
            background: #fff;
            border: 6px solid #fbcfe8;
            border-radius: 1.5rem;
            margin: 0 auto;
            /* Maintaining a clear square aspect ratio */
            aspect-ratio: 1 / 1;
        }

        .font-magic {
            font-family: 'Fredoka One', cursive;
        }

        #timer-bar {
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #f472b6, #a855f7);
        }

        .modal-glass {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
        }

        canvas {
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="flex flex-col items-center p-4">

    <!-- Header / UI -->
    <div class="w-full max-w-2xl mb-4 text-center">
        <h1 class="text-3xl sm:text-4xl font-magic text-pink-600 mb-2 drop-shadow-sm">‚ú® M4 Vocabulary 11-20 ‚ú®</h1>
        <div id="mission-box" class="bg-white/80 p-4 sm:p-5 rounded-2xl border-2 border-pink-200 shadow-lg relative overflow-hidden">
            <p id="definition" class="text-gray-700 font-medium text-base sm:text-lg italic leading-tight">Loading magic...</p>
            <div id="word-display" class="mt-4 flex flex-wrap justify-center gap-1">
                <!-- Word blanks go here -->
            </div>
            <!-- Timer Indicator -->
            <div class="w-full bg-pink-50 h-1.5 mt-4 rounded-full overflow-hidden">
                <div id="timer-bar" class="w-0 transition-all duration-1000"></div>
            </div>
        </div>
    </div>

    <!-- Game Canvas Container -->
    <div id="game-container" class="w-full max-w-[550px] overflow-hidden">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Countdown Overlay -->
        <div id="countdown-overlay" class="absolute inset-0 flex flex-col items-center justify-center z-10 hidden modal-glass">
            <div class="text-8xl font-magic text-pink-500 mb-2 animate-bounce" id="countdown-number">5</div>
            <p class="text-purple-500 font-magic text-xl uppercase tracking-widest">Read the definition!</p>
        </div>

        <!-- Start/Game Over Overlay -->
        <div id="overlay" class="absolute inset-0 flex items-center justify-center modal-glass z-20">
            <div class="text-center p-8">
                <h2 id="overlay-title" class="text-5xl font-magic text-pink-500 mb-4">READY?</h2>
                <p id="overlay-msg" class="text-gray-600 mb-8 text-lg font-medium">Follow the definition and spell the word!</p>
                <button id="start-btn" class="bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white px-10 py-4 rounded-full text-2xl font-magic transition-all hover:scale-105 active:scale-95 shadow-xl">
                    START
                </button>
            </div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div class="grid grid-cols-3 gap-3 mt-8 mb-10 md:hidden">
        <div></div>
        <button id="up" class="bg-pink-100 p-5 rounded-2xl text-2xl shadow-md active:bg-pink-200">‚Üë</button>
        <div></div>
        <button id="left" class="bg-pink-100 p-5 rounded-2xl text-2xl shadow-md active:bg-pink-200">‚Üê</button>
        <button id="down" class="bg-pink-100 p-5 rounded-2xl text-2xl shadow-md active:bg-pink-200">‚Üì</button>
        <button id="right" class="bg-pink-100 p-5 rounded-2xl text-2xl shadow-md active:bg-pink-200">‚Üí</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const definitionEl = document.getElementById('definition');
        const wordDisplayEl = document.getElementById('word-display');
        const overlay = document.getElementById('overlay');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const countdownNumber = document.getElementById('countdown-number');
        const startBtn = document.getElementById('start-btn');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMsg = document.getElementById('overlay-msg');
        const timerBar = document.getElementById('timer-bar');

        const GRID_SIZE = 24;
        let tileCount;
        let width, height;

        let snake = [];
        let particles = [];
        let direction = { x: 0, y: -1 };
        let directionQueue = [];
        let gameActive = false;
        let isReadingPhase = false;
        let currentWordIndex = 0;
        let letterPointer = 0;
        let floatingLetters = [];
        let speed = 200;

        const WORD_DATA = [
            { word: "TURNIP CAKE", definition: "A savoury Cantonese dish made from radishes, rice flour, and sometimes shrimp." },
            { word: "TONG YUEN", definition: "Glutinous rice balls filled with sweet pastes and served in soup; often eaten during the Spring Lantern Festival." },
            { word: "EASTER EGGS", definition: "Small objects filled with sweets or toys and hidden for children to hunt for." },
            { word: "RICE DUMPLINGS", definition: "Rice triangles filled with various meats or fillings and wrapped in bamboo; often eaten during the Dragon Boat Festival." },
            { word: "MOONCAKES", definition: "Small round or square sweets often filled with sweet pastes and egg yolks; often eaten during the Mid-Autumn Festival." },
            { word: "GET RED PACKETS", definition: "Something many kids look forward to during Chinese New Year so that they can earn money from their family." },
            { word: "HAVE A REUNION DINNER", definition: "When families come together to share a meal usually during Chinese New Year and other big festivals." },
            { word: "WATCH FIREWORKS", definition: "When you go to Victoria Harbour to see big lights bursting in the sky over the harbour for Chinese New Year and other holidays." },
            { word: "WATCH A PARADE", definition: "When people go to see other people marching through the streets with floats, music, and performers." },
            { word: "WATCH DRAGON BOAT RACES", definition: "When people go to see teams competing against each other in the water during the Dragon Boat Festival." }
        ];

        const RAINBOW_COLORS = ['#FF4D4D', '#FF9F43', '#FECA57', '#1DD1A1', '#54A0FF', '#5F27CD', '#FF9FF3'];

        function resizeCanvas() {
            // Restore original logic: based on container width to keep size consistent
            const container = document.getElementById('game-container');
            const size = container.clientWidth;
            
            // Ensure size is a multiple of GRID_SIZE
            const finalSize = Math.floor(size / GRID_SIZE) * GRID_SIZE;
            
            canvas.width = finalSize;
            canvas.height = finalSize;
            width = canvas.width;
            height = canvas.height;
            tileCount = width / GRID_SIZE;
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });
        resizeCanvas();

        function startNewRound() {
            isReadingPhase = true;
            gameActive = false;
            overlay.classList.add('hidden');
            
            snake = [
                { x: Math.floor(tileCount/2), y: Math.floor(tileCount/2) },
                { x: Math.floor(tileCount/2), y: Math.floor(tileCount/2) + 1 },
                { x: Math.floor(tileCount/2), y: Math.floor(tileCount/2) + 2 }
            ];
            direction = { x: 0, y: -1 };
            directionQueue = [];
            letterPointer = 0;
            particles = [];
            
            currentWordIndex = Math.floor(Math.random() * WORD_DATA.length);
            
            setupWordUI();
            spawnLetters();
            draw(); 
            startReadingCountdown();
        }

        async function startReadingCountdown() {
            countdownOverlay.classList.remove('hidden');
            let timeLeft = 5;
            while (timeLeft > 0) {
                countdownNumber.textContent = timeLeft;
                timerBar.style.width = (timeLeft * 20) + "%";
                await new Promise(r => setTimeout(r, 1000));
                timeLeft--;
            }
            timerBar.style.width = "0%";
            countdownOverlay.classList.add('hidden');
            isReadingPhase = false;
            gameActive = true;
            gameLoop();
        }

        function setupWordUI() {
            const data = WORD_DATA[currentWordIndex];
            definitionEl.textContent = data.definition;
            wordDisplayEl.innerHTML = '';
            
            for (let i = 0; i < data.word.length; i++) {
                const char = data.word[i];
                const span = document.createElement('span');
                if (char === ' ') {
                    span.className = "w-4";
                    span.textContent = "";
                } else if (!/[A-Z]/.test(char.toUpperCase())) {
                    span.className = "text-pink-400 font-magic text-2xl px-1";
                    span.textContent = char;
                } else {
                    span.className = "w-8 h-10 border-b-4 border-pink-100 flex items-center justify-center text-xl font-magic text-gray-200 transition-colors";
                    span.textContent = "?";
                    span.id = `letter-${i}`;
                }
                wordDisplayEl.appendChild(span);
            }
            adjustPointer();
        }

        function adjustPointer() {
            const word = WORD_DATA[currentWordIndex].word;
            while (letterPointer < word.length && !/[A-Z]/.test(word[letterPointer].toUpperCase())) {
                letterPointer++;
            }
        }

        function spawnLetters() {
            floatingLetters = [];
            const word = WORD_DATA[currentWordIndex].word;
            const targetLetter = word[letterPointer].toUpperCase();
            addLetter(targetLetter, true);

            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            for(let i = 0; i < 4; i++) {
                let randomChar = alphabet[Math.floor(Math.random() * alphabet.length)];
                if (randomChar === targetLetter) randomChar = (targetLetter === 'X' ? 'Y' : 'X');
                addLetter(randomChar, false);
            }
        }

        function addLetter(char, isTarget) {
            let x, y, overlap;
            let attempts = 0;
            do {
                overlap = false;
                x = Math.floor(Math.random() * tileCount);
                y = Math.floor(Math.random() * tileCount);
                if (snake.some(p => p.x === x && p.y === y)) overlap = true;
                if (floatingLetters.some(l => l.x === x && l.y === y)) overlap = true;
                attempts++;
            } while (overlap && attempts < 100);
            floatingLetters.push({ char, x, y, isTarget });
        }

        function draw() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, width, height);

            // Particles
            particles = particles.filter(p => p.life > 0.1);
            particles.forEach(p => {
                p.life -= 0.02; p.x += p.vx; p.y += p.vy;
                ctx.fillStyle = `rgba(${p.color}, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.max(0.1, p.size * p.life), 0, Math.PI * 2);
                ctx.fill();
            });

            // Letters
            floatingLetters.forEach(l => {
                const centerX = l.x * GRID_SIZE + GRID_SIZE/2;
                const centerY = l.y * GRID_SIZE + GRID_SIZE/2;
                ctx.fillStyle = '#fdf2f8';
                ctx.beginPath();
                ctx.arc(centerX, centerY, GRID_SIZE * 0.45, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = l.isTarget ? '#f472b6' : '#fbcfe8';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.font = 'bold 18px "Fredoka One", Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#be185d';
                ctx.fillText(l.char, centerX, centerY);
            });

            // Snake
            snake.forEach((part, index) => {
                const posX = part.x * GRID_SIZE;
                const posY = part.y * GRID_SIZE;
                ctx.fillStyle = RAINBOW_COLORS[index % RAINBOW_COLORS.length];
                if (index === 0) {
                    ctx.font = `${GRID_SIZE}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ü¶Ñ', posX + GRID_SIZE/2, posY + GRID_SIZE/2);
                } else {
                    ctx.beginPath();
                    ctx.roundRect(posX + 1, posY + 1, GRID_SIZE - 2, GRID_SIZE - 2, 6);
                    ctx.fill();
                }
            });
        }

        function update() {
            if (directionQueue.length > 0) {
                const next = directionQueue.shift();
                if (next.x !== -direction.x || next.y !== -direction.y) {
                    direction = next;
                }
            }

            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver("Oops! You hit the edge!"); return;
            }
            if (snake.some(p => p.x === head.x && p.y === head.y)) {
                gameOver("Careful! Don't trip on your rainbow!"); return;
            }

            snake.unshift(head);
            let eaten = false;
            for (let i = 0; i < floatingLetters.length; i++) {
                const l = floatingLetters[i];
                if (l.x === head.x && l.y === head.y) {
                    if (l.isTarget) {
                        handleCorrectLetter(); eaten = true;
                    } else {
                        gameOver(`Need "${WORD_DATA[currentWordIndex].word[letterPointer]}", not "${l.char}"!`);
                        return;
                    }
                    break;
                }
            }
            if (!eaten) snake.pop();
        }

        function handleCorrectLetter() {
            const word = WORD_DATA[currentWordIndex].word;
            const el = document.getElementById(`letter-${letterPointer}`);
            if (el) {
                el.textContent = word[letterPointer];
                el.classList.remove('text-gray-200');
                el.classList.add('text-pink-600', 'border-pink-500');
            }
            for(let i=0; i<12; i++) {
                particles.push({x: snake[0].x*GRID_SIZE+GRID_SIZE/2, y: snake[0].y*GRID_SIZE+GRID_SIZE/2, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 1, size: 8, color: "255, 215, 0"});
            }
            letterPointer++;
            adjustPointer();
            if (letterPointer >= word.length) {
                gameActive = false;
                setTimeout(victory, 500);
            } else {
                spawnLetters();
            }
        }

        function victory() {
            overlayTitle.textContent = "‚ú® MAGICAL! ‚ú®";
            overlayMsg.textContent = `Perfect spelling! Ready for another?`;
            overlay.classList.remove('hidden');
            startBtn.textContent = "NEXT WORD";
        }

        function gameOver(msg) {
            gameActive = false;
            overlayTitle.textContent = "TRY AGAIN!";
            overlayMsg.textContent = msg;
            overlay.classList.remove('hidden');
            startBtn.textContent = "RESTART";
        }

        function gameLoop() {
            if (!gameActive) {
                draw();
                if (isReadingPhase) requestAnimationFrame(gameLoop);
                return;
            }
            update();
            draw();
            setTimeout(() => requestAnimationFrame(gameLoop), speed);
        }

        function queueDirection(x, y) {
            if (isReadingPhase || !gameActive) return;
            const last = directionQueue.length > 0 ? directionQueue[directionQueue.length - 1] : direction;
            if (x !== last.x || y !== last.y) {
                if (directionQueue.length < 2) directionQueue.push({ x, y });
            }
        }

        window.addEventListener('keydown', e => {
            switch(e.key) {
                case 'ArrowUp': case 'w': queueDirection(0, -1); break;
                case 'ArrowDown': case 's': queueDirection(0, 1); break;
                case 'ArrowLeft': case 'a': queueDirection(-1, 0); break;
                case 'ArrowRight': case 'd': queueDirection(1, 0); break;
            }
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
        });

        // Touch handlers
        const btns = ['up', 'down', 'left', 'right'];
        const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
        btns.forEach((id, i) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => {
                e.preventDefault();
                queueDirection(dirs[i].x, dirs[i].y);
            });
            el.onclick = () => queueDirection(dirs[i].x, dirs[i].y);
        });

        startBtn.onclick = startNewRound;
        resizeCanvas();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
